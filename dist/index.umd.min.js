!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(void 0!==(e=e||self)?e:window).promisie=t()}(this,function(){"use strict";const e=Symbol("isPending"),t=Symbol("isFulfulled"),n=Symbol("isRejected"),r=Symbol("isPaused");class i{constructor(r){this.action=r.action,this.timeout=r.timeout||0,this.index=r.index,this.value=r.value,this[e]=!0,this[t]=!1,this[n]=!1,this.fulfill=function(e,t){if("number"==typeof this.timeout&&this.timeout>0){const n=setTimeout(()=>{this.value=e,t(e),clearTimeout(n)},this.timeout)}else this.value=e,t(e)}.bind(this),this.reject=function(e,t){if("number"==typeof this.timeout){const n=setTimeout(()=>{t(e),clearTimeout(n)},this.timeout)}else t(e)}.bind(this),this.next=void 0}resolve(e){return new Promise((t,n)=>{try{const r="function"==typeof this.action?this.action(e):this.action;if(r&&"function"==typeof r.then&&"function"==typeof r.catch)return r.then(e=>this.fulfill(e,t)).catch(e=>this.reject(e,n));this.fulfill(r,t)}catch(e){this.reject(e,n)}})}}function o(e,t){for(;this.active<this.concurrency&&this.current;){this.active++;let r=this.current;this.current=r.next,r.action=this.action,r.resolve(r.value).then(n=>{0!=--this.active||this.current?this.resolve(e,t):e(this.decompress(this.root))},e=>{this[n]=!0,t(e)})}}class s{constructor(e){this.action=e.action,this.concurrency=e.concurrency||1/0,this.values=e.values||[],this.active=0,this.timeout=e.timeout||0,this.current=void 0,this[r]=!1,this[n]=!1,this.root=void 0,this.length=0,this.decompress=(e.decompress||function(e){let t=[],n=e;for(;n;)t.push(n.value),n=n.next;return t}).bind(this)}insert(...e){for(let t=0;t<e.length;t++)if(this.length++,this.root){let n=this.root;for(;n&&n.next;)n=n.next;n.next=new i({index:t,action:void 0,value:e[t],timeout:this.timeout})}else this.root=new i({index:t,action:void 0,value:e[t],timeout:this.timeout});return this.current=this.root,this}resolve(e,t){return!this.current||this[n]||this[r]?null:e&&t?void o.call(this,e,t):new Promise((e,t)=>{o.call(this,e,t)})}}function c(e=0){return new Promise(t=>{let n=setTimeout(function(){clearTimeout(n),t()},e)})}function u(e,t){return e.map(e=>{const n="object"==typeof t?Array.isArray(t)?Object.assign([],t):Object.assign({},t):t;return"function"==typeof e?e(n):e})}var l={safeAssign:function(e){let t={};for(let n in e){let r=Object.getOwnPropertyDescriptor(e,n);r&&r.writable&&(t[n]=e[n])}return t},map:function(e,t,n,r){const i="function"==typeof n?n:r;return new s({action:e,concurrency:"number"==typeof n?n:void 0}).insert(...t).resolve().then(e=>i(null,e)).catch(i)},parallel:function(e,t,n,r){const i="function"==typeof n?n:r;return new s({action:e=>{const{operation:n,key:r}=e;if("function"==typeof n){if(Array.isArray(t)){const e=t;return Promise.all([n(...e),r])}return Promise.all([n(t),r])}return[n,r]},concurrency:"number"==typeof n?n:void 0,decompress:e=>{const t={};let n=e;for(;n;){const[e,r]=n.value;t[r]=e,n=n.next}return t}}).insert(...Object.keys(e).map(t=>({operation:e[t],key:t}))).resolve().then(e=>i(null,e)).catch(i)},handleRecursiveParallel:function e(t){return Object.keys(t).reduce((n,r)=>(t[r]&&"object"==typeof t[r]?n[r]=(()=>f.parallel(e(t[r]))):n[r]=t[r],n),{})},settle:function(e,t,n){const r="function"==typeof t?t:n,i=[],o=[];return new s({action(e){if("function"==typeof e)try{const t=e();if(t&&"function"==typeof t.then&&"function"==typeof t.catch)return t.then(e=>{i.push({value:e,status:"fulfilled"})},e=>{o.push({value:e,status:"rejected"})});i.push({value:t,status:"fulfilled"})}catch(e){o.push({value:e,status:"rejected"})}else i.push({value:e,status:"fulfilled"});return null},decompress:e=>null,concurrency:"number"==typeof t?t:void 0}).insert(...e).resolve().then(()=>r(null,{fulfilled:i,rejected:o})).catch(r)},iterator:function(e){return function t(n,r){let i;try{i=e.next(n)}catch(e){r(e)}i||r(new Error("ERROR: generator returned 'undefined' value and is not iterable"));const{done:o,value:s}=i||{done:!0,value:null};if(o)r(null,s);else if(s&&"function"==typeof s.then&&"function"==typeof s.catch)s.then(e=>t(e,r),r);else{let e=setTimeout(()=>{t(s,r),clearTimeout(e)},0)}}},doWhilst:function(e,t){let n;return function*(){do{const t=e();t&&"function"==typeof t.then&&"function"==typeof t.catch?yield t.then(e=>n=e,e=>Promise.reject(e)):(n=t,yield n)}while(t(n))}},retry:function(e,t){let n,r=!0,{times:i,timeout:o}=t;return function*(){do{i--;let t=r||"number"!=typeof o||0===o?e():(()=>c(o).then(e).catch(e=>Promise.reject(e)))();r=!1,t&&"function"==typeof t.then&&"function"==typeof t.catch?yield t.then(e=>n={__isRejected:!1,e:null,value:e},e=>n={__isRejected:!0,e:e,value:null}):(n={__isRejected:!1,e:null,value:t},yield n)}while(i&&n&&Object.hasOwnProperty.call(n,"__isRejected"));return n}},series:function(e){return function*(){let t,n;for(;e.length;)if(t=e.shift(),Array.isArray(t)){const e=Promise.all(u(t,n)).then(e=>Array.isArray(n)?n.concat(e):e).catch(e=>Promise.reject(e));n=yield e}else void 0!==t&&(n=yield t(n));return n}}};function a(e,t){return{success:e,failure:"function"==typeof t?t:void 0}}class f extends Promise{constructor(e){super(e)}then(e,t){return super.then(e,t)}try(e,t){const{success:n,failure:r}=a(function(t){try{return"function"==typeof e?e(t):f.reject(new TypeError("ERROR: try expects onSuccess handler to be a function"))}catch(e){return f.reject(e)}},t);return this.then(n,r)}spread(e,t){const{success:n,failure:r}=a(function(t){return"function"!=typeof t[Symbol.iterator]?f.reject(new TypeError("ERROR: spread expects input to be iterable")):"function"!=typeof e?f.reject(new TypeError("ERROR: spread expects onSuccess handler to be a function")):e(...t)},t);return this.then(n,r)}map(e,t,n){"number"==typeof t&&(n=t,t=void 0);const{success:r,failure:i}=a(function(t){return Array.isArray(t)?"function"!=typeof e?f.reject(new TypeError("ERROR: map expects onSuccess handler to be a function")):f.map(t,n,e):f.reject(new TypeError("ERROR: map expects input to be an array"))},t);return this.then(r,i)}each(e,t,n){"number"==typeof t&&(n=t,t=void 0);const{success:r,failure:i}=a(function(t){return Array.isArray(t)?"function"!=typeof e?f.reject(new TypeError("ERROR: each expects onSuccess handler to be a function")):f.each(t,n,e):f.reject(new TypeError("ERROR: each expects input to be an array"))},t);return this.then(r,i)}settle(e,t){const{success:n,failure:r}=a(function(t){if(!Array.isArray(t))return f.reject(new TypeError("ERROR: settle expects input to be an array"));if("function"!=typeof e)return f.reject(new TypeError("ERROR: settle expects onSuccess handler to be a function"));const n=t.map(t=>()=>e(t));return f.settle(n)},t);return this.then(n,r)}retry(e,t,n){t&&"object"==typeof t&&(n=t,t=void 0);const{success:r,failure:i}=a(function(t){return"function"!=typeof e?f.reject(new TypeError("ERROR: retry expects onSuccess handler to be a function")):f.retry(()=>e(t),n)},t);return this.then(r,i)}finally(e){const t=()=>"function"==typeof e?e():f.reject(new TypeError("ERROR: finally expects handler to be a function"));return this.then(t,t)}static promisify(e,t){const n=function(...t){return new f((n,r)=>{t.push(function(e,t){e?r(e):n(t)}),e.apply(this,t)})};return t?n.bind(t):n}static promisifyAll(e,t,n){const r=Object.assign({readonly:!0,recursive:!1},n);let i=Object.create(e);i=r.readonly?l.safeAssign(e):Object.assign(i,e);const o={};return Object.keys(i).forEach(e=>{if("function"==typeof i[e])o[`${e}Async`]=t?this.promisify(i[e],t):this.promisify(i[e]);else if(r.recursive){const n=i[e];(function(e){return e&&"object"==typeof e})(n)&&(o[e]=this.promisifyAll(n,t,r))}}),o}static series(e){return f.iterate(l.series(e),null)}static pipe(e){return function(...t){const n=Object.assign([],e),r=n[0];return n[0]=function(){return r(...t)},f.series(n)}}static compose(e){return f.pipe(e.reverse())}static map(e,t,n){const r="function"==typeof t?t:n;return"number"!=typeof t&&(t=1),f.promisify(l.map)(r,e,t)}static each(e,t,n){return f.map(e,t,n).then(()=>e)}static parallel(e,t,n={}){const{recursive:r=!1,concurrency:i}=n;return r&&(e=l.handleRecursiveParallel(e)),f.promisify(l.parallel)(e,t,i)}static settle(e,t){return f.promisify(l.settle)(e,t)}static iterate(e,t){const n=l.iterator(e(t));return f.promisify(n)(t)}static doWhilst(e,t){return f.iterate(l.doWhilst(e,t),null)}static sleep(e){return new f(t=>{setTimeout(()=>{t()},e)})}static retry(e,t){const{times:n=3,timeout:r=0}=t||{};return f.iterate(l.retry(e,{times:n,timeout:r}),null).then(e=>{const{__isRejected:t,e:n,value:r}=e;return t?f.reject(n):f.resolve(r)})}}return f});
