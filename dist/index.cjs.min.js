"use strict";function safeAssign(e){let t={};for(let r in e){let i=Object.getOwnPropertyDescriptor(e,r);i&&i.writable&&(t[r]=e[r])}return t}Object.defineProperty(exports,"__esModule",{value:!0});const IS_PENDING=Symbol("isPending"),IS_FULFILLED=Symbol("isFulfulled"),IS_REJECTED=Symbol("isRejected"),IS_PAUSED=Symbol("isPaused");function fulfill(e,t){if("number"==typeof this.timeout&&this.timeout>0){const r=setTimeout(()=>{this.value=e,t(e),clearTimeout(r)},this.timeout)}else this.value=e,t(e)}function reject(e,t){if("number"==typeof this.timeout){const r=setTimeout(()=>{t(e),clearTimeout(r)},this.timeout)}else t(e)}class QueueNode{constructor(e){this.action=e.action,this.timeout=e.timeout||0,this.index=e.index,this.value=e.value,this[IS_PENDING]=!0,this[IS_FULFILLED]=!1,this[IS_REJECTED]=!1,this.fulfill=fulfill.bind(this),this.reject=reject.bind(this),this.next=void 0}resolve(e){return new Promise((t,r)=>{try{const i="function"==typeof this.action?this.action(e):this.action;if(i&&"function"==typeof i.then&&"function"==typeof i.catch)return i.then(e=>this.fulfill(e,t)).catch(e=>this.reject(e,r));this.fulfill(i,t)}catch(e){this.reject(e,r)}})}}function decompress(e){let t=[],r=e;for(;r;)t.push(r.value),r=r.next;return t}function handleResolve(e,t){for(;this.active<this.concurrency&&this.current;){this.active++;let r=this.current;this.current=r.next,r.action=this.action,r.resolve(r.value).then(r=>{0!=--this.active||this.current?this.resolve(e,t):e(this.decompress(this.root))},e=>{this[IS_REJECTED]=!0,t(e)})}}class Queue{constructor(e){this.action=e.action,this.concurrency=e.concurrency||1/0,this.values=e.values||[],this.active=0,this.timeout=e.timeout||0,this.current=void 0,this[IS_PAUSED]=!1,this[IS_REJECTED]=!1,this.root=void 0,this.length=0,this.decompress=(e.decompress||decompress).bind(this)}insert(...e){for(let t=0;t<e.length;t++)if(this.length++,this.root){let r=this.root;for(;r&&r.next;)r=r.next;r.next=new QueueNode({index:t,action:void 0,value:e[t],timeout:this.timeout})}else this.root=new QueueNode({index:t,action:void 0,value:e[t],timeout:this.timeout});return this.current=this.root,this}resolve(e,t){return!this.current||this[IS_REJECTED]||this[IS_PAUSED]?null:e&&t?void handleResolve.call(this,e,t):new Promise((e,t)=>{handleResolve.call(this,e,t)})}}function map(e,t,r,i){const n="function"==typeof r?r:i;return new Queue({action:e,concurrency:"number"==typeof r?r:void 0}).insert(...t).resolve().then(e=>n(null,e)).catch(n)}function parallel(e,t,r,i){const n="function"==typeof r?r:i;return new Queue({action:e=>{const{operation:r,key:i}=e;if("function"==typeof r){if(Array.isArray(t)){const e=t;return Promise.all([r(...e),i])}return Promise.all([r(t),i])}return[r,i]},concurrency:"number"==typeof r?r:void 0,decompress:e=>{const t={};let r=e;for(;r;){const[e,i]=r.value;t[i]=e,r=r.next}return t}}).insert(...Object.keys(e).map(t=>({operation:e[t],key:t}))).resolve().then(e=>n(null,e)).catch(n)}function handleRecursiveParallel(e){return Object.keys(e).reduce((t,r)=>(e[r]&&"object"==typeof e[r]?t[r]=(()=>Promisie.parallel(handleRecursiveParallel(e[r]))):t[r]=e[r],t),{})}function settle(e,t,r){const i="function"==typeof t?t:r,n=[],s=[];return new Queue({action(e){if("function"==typeof e)try{const t=e();if(t&&"function"==typeof t.then&&"function"==typeof t.catch)return t.then(e=>{n.push({value:e,status:"fulfilled"})},e=>{s.push({value:e,status:"rejected"})});n.push({value:t,status:"fulfilled"})}catch(e){s.push({value:e,status:"rejected"})}else n.push({value:e,status:"fulfilled"});return null},decompress:e=>null,concurrency:"number"==typeof t?t:void 0}).insert(...e).resolve().then(()=>i(null,{fulfilled:n,rejected:s})).catch(i)}function iterator(e){return function t(r,i){let n;try{n=e.next(r)}catch(e){i(e)}n||i(new Error("ERROR: generator returned 'undefined' value and is not iterable"));const{done:s,value:o}=n||{done:!0,value:null};if(s)i(null,o);else if(o&&"function"==typeof o.then&&"function"==typeof o.catch)o.then(e=>t(e,i),i);else{let e=setTimeout(()=>{t(o,i),clearTimeout(e)},0)}}}function makeDoWhilstGenerator(e,t){let r;return function*(){do{const t=e();t&&"function"==typeof t.then&&"function"==typeof t.catch?yield t.then(e=>r=e,e=>Promise.reject(e)):(r=t,yield r)}while(t(r))}}function timeout(e=0){return new Promise(t=>{let r=setTimeout(function(){clearTimeout(r),t()},e)})}function makeRetryGenerator(e,t){let r,i=!0,{times:n,timeout:s}=t;return function*(){do{n--;let t=i||"number"!=typeof s||0===s?e():(()=>timeout(s).then(e).catch(e=>Promise.reject(e)))();i=!1,t&&"function"==typeof t.then&&"function"==typeof t.catch?yield t.then(e=>r={__isRejected:!1,e:null,value:e},e=>r={__isRejected:!0,e:e,value:null}):(r={__isRejected:!1,e:null,value:t},yield r)}while(n&&r&&Object.hasOwnProperty.call(r,"__isRejected"));return r}}function handleMap(e,t){return e.map(e=>{const r="object"==typeof t?Array.isArray(t)?Object.assign([],t):Object.assign({},t):t;return"function"==typeof e?e(r):e})}function makeSeriesGenerator(e){return function*(){let t,r;for(;e.length;)if(t=e.shift(),Array.isArray(t)){const e=Promise.all(handleMap(t,r)).then(e=>Array.isArray(r)?r.concat(e):e).catch(e=>Promise.reject(e));r=yield e}else void 0!==t&&(r=yield t(r));return r}}var utilities={safeAssign:safeAssign,map:map,parallel:parallel,handleRecursiveParallel:handleRecursiveParallel,settle:settle,iterator:iterator,doWhilst:makeDoWhilstGenerator,retry:makeRetryGenerator,series:makeSeriesGenerator};function isNestedPromisifyAllObjectParam(e){return e&&"object"==typeof e}function setHandlers(e,t){return{success:e,failure:"function"==typeof t?t:void 0}}class Promisie extends Promise{constructor(e){super(e)}then(e,t){return super.then(e,t)}try(e,t){const{success:r,failure:i}=setHandlers(function(t){try{return"function"==typeof e?e(t):Promisie.reject(new TypeError("ERROR: try expects onSuccess handler to be a function"))}catch(e){return Promisie.reject(e)}},t);return this.then(r,i)}spread(e,t){const{success:r,failure:i}=setHandlers(function(t){return"function"!=typeof t[Symbol.iterator]?Promisie.reject(new TypeError("ERROR: spread expects input to be iterable")):"function"!=typeof e?Promisie.reject(new TypeError("ERROR: spread expects onSuccess handler to be a function")):e(...t)},t);return this.then(r,i)}map(e,t,r){"number"==typeof t&&(r=t,t=void 0);const{success:i,failure:n}=setHandlers(function(t){return Array.isArray(t)?"function"!=typeof e?Promisie.reject(new TypeError("ERROR: map expects onSuccess handler to be a function")):Promisie.map(t,r,e):Promisie.reject(new TypeError("ERROR: map expects input to be an array"))},t);return this.then(i,n)}each(e,t,r){"number"==typeof t&&(r=t,t=void 0);const{success:i,failure:n}=setHandlers(function(t){return Array.isArray(t)?"function"!=typeof e?Promisie.reject(new TypeError("ERROR: each expects onSuccess handler to be a function")):Promisie.each(t,r,e):Promisie.reject(new TypeError("ERROR: each expects input to be an array"))},t);return this.then(i,n)}settle(e,t){const{success:r,failure:i}=setHandlers(function(t){if(!Array.isArray(t))return Promisie.reject(new TypeError("ERROR: settle expects input to be an array"));if("function"!=typeof e)return Promisie.reject(new TypeError("ERROR: settle expects onSuccess handler to be a function"));const r=t.map(t=>()=>e(t));return Promisie.settle(r)},t);return this.then(r,i)}retry(e,t,r){t&&"object"==typeof t&&(r=t,t=void 0);const{success:i,failure:n}=setHandlers(function(t){return"function"!=typeof e?Promisie.reject(new TypeError("ERROR: retry expects onSuccess handler to be a function")):Promisie.retry(()=>e(t),r)},t);return this.then(i,n)}finally(e){const t=()=>"function"==typeof e?e():Promisie.reject(new TypeError("ERROR: finally expects handler to be a function"));return this.then(t,t)}static promisify(e,t){const r=function(...t){return new Promisie((r,i)=>{t.push(function(e,t){e?i(e):r(t)}),e.apply(this,t)})};return t?r.bind(t):r}static promisifyAll(e,t,r){const i=Object.assign({readonly:!0,recursive:!1},r);let n=Object.create(e);n=i.readonly?utilities.safeAssign(e):Object.assign(n,e);const s={};return Object.keys(n).forEach(e=>{if("function"==typeof n[e])s[`${e}Async`]=t?this.promisify(n[e],t):this.promisify(n[e]);else if(i.recursive){const r=n[e];isNestedPromisifyAllObjectParam(r)&&(s[e]=this.promisifyAll(r,t,i))}}),s}static series(e){return Promisie.iterate(utilities.series(e),null)}static pipe(e){return function(...t){const r=Object.assign([],e),i=r[0];return r[0]=function(){return i(...t)},Promisie.series(r)}}static compose(e){return Promisie.pipe(e.reverse())}static map(e,t,r){const i="function"==typeof t?t:r;return"number"!=typeof t&&(t=1),Promisie.promisify(utilities.map)(i,e,t)}static each(e,t,r){return Promisie.map(e,t,r).then(()=>e)}static parallel(e,t,r={}){const{recursive:i=!1,concurrency:n}=r;return i&&(e=utilities.handleRecursiveParallel(e)),Promisie.promisify(utilities.parallel)(e,t,n)}static settle(e,t){return Promisie.promisify(utilities.settle)(e,t)}static iterate(e,t){const r=utilities.iterator(e(t));return Promisie.promisify(r)(t)}static doWhilst(e,t){return Promisie.iterate(utilities.doWhilst(e,t),null)}static sleep(e){return new Promisie(t=>{setTimeout(()=>{t()},e)})}static retry(e,t){const{times:r=3,timeout:i=0}=t||{};return Promisie.iterate(utilities.retry(e,{times:r,timeout:i}),null).then(e=>{const{__isRejected:t,e:r,value:i}=e;return t?Promisie.reject(r):Promisie.resolve(i)})}}exports.default=Promisie;
